*** Begin Patch
*** Update File: README.md
@@
 ## Storage Access Gate (offline blobs)
 
 - `storage::gate` реализует анонимный доступ к оффлайн-blob’ам: gate выдаёт `BlobFetchChallenge { blob_id, nonce }`, а устройство формирует `BlobFetchRequest` через `BlobIdentityProver`, используя тот же Schnорр-процедурный каркас, но с доменом `b"zk-gatekeeper-blob-v1"` и challenge = `blob_id || nonce`. Identity не раскрывается на транспортном уровне — gate хранит соответствие `(blob_id, IdentityIdentifier, public_key)` и сверяет proof локально.
 - `BlobAccessGate` совместим с P2P-хранилищем (Waku Store и т. п.): запросы содержат минимум метаданных (`blob_id`, `nonce`, `proof`) и могут пересылаться как Waku payload'ы. Gate регистрирует права доступа через `BlobAccessEntry`, делает ревокацию (`revoke`) и возвращает `BlobAccessGrant` при успешной проверке.
 - Для интеграции с Waku: узел публикует `blob_id` в качестве темы (`/zk-gatekeeper/blob/<hex>`) и отвечает на fetch-запросы только при получении валидного `BlobFetchRequest`. Challenge можно распространять по side-channel (например, Waku Request/Response или out-of-band), что предотвращает воспроизведение и минимизирует утечки.
+
+## Форматы и API
+
+- **Flash-record v1**: `magic(4="ZKGS") | version(1) | reserved(1) | payload_len(2=64) | counter(4) | reserved(4) | device_id(16) | ciphertext(64: sk_user || pk_user) | mac(32)`; ciphertext шифруется HKDF-ключом хранилища, MAC = HMAC-SHA256(header || ciphertext). Проверки выполняются в `storage::flash`.
+- **ZkProof v1**: `version(1) | payload_len(1=64) | commitment(32) | response(32)` (см. `zk::proof`). Любые изменения требуют bump версии.
+- **Публичный ключ**: 32 байта сжатой точки Ed25519 (Curve25519 Edwards). Возвращается через `IdentityState::public_key()`.
+- **Основные API**: `identity::{init, seed, link, persist}`, `handshake::{initiator_start,responder_accept,ratchet}`, `storage::{flash,secure,gate}`, `contacts::ContactTree`, `zk::{prover,verifier}` — README описывает, в каком порядке их вызывать.
+
+## Тесты
+
+### Юнит-тесты
+
+- `tests/identity.rs` — идентификаторы и seed-фразы.
+- `tests/hkdf.rs` — детерминизм HKDF и независимость ключей.
+- `tests/zk.rs` — prover ↔ verifier и replay.
+- `tests/contacts.rs` — Merkle-древо контактов.
+- `tests/storage_gate.rs` — blob gate.
+- `tests/handshake.rs` — Noise handshake + Double Ratchet.
+- `tests/storage_secure.rs` (TODO) — WAL/снимки (заготовка оставить на следующий этап).
+
+### Интеграционные сценарии
+
+- Устройство ↔ verifier: см. `tests/zk.rs::prover_verifier_roundtrip`.
+- Device linking: тесты в `identity/link.rs` (планируется расширить до e2e).
+- Replay-атаки: `tests/zk.rs::replay_detected` + `storage::gate::BlobAccessGate::verify`.
+
+Для запуска: `cargo test --tests` (для host-проверок) и `cargo test --target thumbv6m-none-eabi` (после установки `rustup target add`).
+
+## Документация и протоколы
+
+- README описывает форматы flash/ZK/handshake, API вызовов и роли подсистем. Для визуальных протокольных диаграмм используйте PlantUML (пример шаблона — `docs/diagrams/handshake.puml`, TODO).
+- Публичные заголовки (`src/lib.rs`, модульные README в будущем) документируют точки входа.
+
+## no_std-аудит и сборка
+
+- Проект `#![no_std]`; зависимости (`curve25519-dalek`, `x25519-dalek`, `hmac`, `sha2`, `zeroize`) используются без std-фич. Проверяйте командой `cargo check --no-default-features --target thumbv6m-none-eabi`.
+- Размер бинаря: `cargo build --release --target thumbv6m-none-eabi` + `cargo size --target thumbv6m-none-eabi` (через `llvm-size`).
+- Рекомендуется периодически запускать `cargo tree --edges no-dev` для проверки зависимостей.
*** End Patch
