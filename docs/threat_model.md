# Модель угроз Gatekeeper

## Область защиты

- **Секреты:** `root_key`, `sk_user`, мастер-ключи LittleFS, sealed состояние личности.
- **Цель:** предотвратить извлечение или подмену секретов, гарантировать целостность личности, обеспечить проверяемость ZK-доказательств.
- **Платформа:** RP2040 и совместимые MCU без MMU и без аппаратного TRNG.

## Предположения

- Код Gatekeeper прошит поверх доверенного загрузчика (Secure Boot проверяет подпись).
- Прошивка и конфигурация фьюзов/bootloader не модифицируются после производства.
- Нападающий может полностью читать Flash/SRAM и имеет физический доступ, но не может постоянно модифицировать питание или часы (иначе secure boot не гарантируется).
- Root seed/фразы хранятся вне устройства или в памяти пользователя.

## Атакующие

1. **Удалённый собеседник:** пытается заставить устройство раскрыть `sk_user`, принимает участие в протоколах ZK и handshake.
2. **Локальный любопытный пользователь:** может считывать Flash через SWD, но не знает `root_key`.
3. **Злонамеренный сервис/host:** взаимодействует по UART/USB/SPI и посылает произвольные challenge, пытается повторно воспроизвести proof.
4. **Физический атакующий:** вскрывает корпус, измеряет RAM после сбоя питания, пробует glitching.

## Границы доверия

- **Trusted Computing Base:** bootloader + прошивка Gatekeeper + secure vault (PUF/DeviceBindingKey).
- **Надёжный канал:** только после успешного ZK-пруфа и Noise/Double Ratchet.
- **Ненадёжное хранилище:** Flash рассматривается как атакуемое, данные защищаются шифрованием + MAC.

## Защитные механизмы

- **Энтропия:** Rp2040Entropy смешивает ROSC, таймер и шум SRAM; отказ при деградации.
- **Ключевая иерархия:** `root_key` → `sk_user` + storage keys через HKDF с domain separation.
- **Secure Vault:** секреты шифруются и привязываются к DeviceBindingKey (PUF).
- **Seal/Unseal:** HMAC, счётчики (epoch/counter), защиту от wrap-around и проверку формата.
- **ZK-протокол:** детерминированный Schnorr с domain separation, challenge tracker с LRU/TTL.
- **Replay защита:** verifier хранит использованные challenge, prover не кэширует proof.
- **Zeroization:** временные буферы и scalars очищаются после использования.
- **Allocator:** `embedded-alloc` инициализируется из статического буфера; без инициализации `Vec`/`Box` не используются.

## Векторы атак и ответы

| Вектор                       | Митигирование                                                                 |
|------------------------------|-------------------------------------------------------------------------------|
| Чтение Flash                 | Запись только шифрованного sealed состояния + secure vault для `sk_user`.    |
| Подмена данных               | HMAC-SHA256 по заголовку и payload; проверка версии и длины.                 |
| Replay proof                 | ChallengeTracker c TTL + LRU; повторный challenge → ошибка `ReplayDetected`. |
| Сбой питания при seal        | Запись в новый слот + проверка записи, счётчики не уменьшаются.              |
| Недоступность ROSC           | Энтропия возвращает `EntropyUnavailable`, инициализация прерывается.         |
| Физический доступ к RAM      | Регулярное zeroization секретов и временных буферов; sealed state в vault.   |
| Host пытается подменить FW   | Secure Boot (FirmwareGuard) проверяет подпись перед `unseal`.                |

## Ограничения

- RP2040 не содержит аппаратных механизмов защиты от fault injection → требуется аппаратный hardening (конформное покрытие, тамперы) вне ПО.
- Прошивка предполагает корректную калибровку ROSC; если ROSC отключён, система не стартует.
- Устройство без `embedded-alloc` должно предоставить собственный глобальный аллокатор или избегать `alloc`-типов.

## Сценарии использования

1. **Сингл-девайс:** устройство генерирует личность, сохраняет sealed состояние и выполняет prover → verifier (телефон).
2. **Мульти-девайс:** восстановление через seed, добавление второго устройства через `DeviceEnrollment`.
3. **Контакт-лист:** Poseidon Merkle-tree хранится во Flash (LittleFS) и обновляется при добавлении контактов; ZK-пруф подтверждает членство PK в дереве.
4. **Оффлайн-доступ:** Storage Gate выдаёт blob'ы после успешного доказательства идентичности.
